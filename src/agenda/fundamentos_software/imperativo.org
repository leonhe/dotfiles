#+TITLE: Paradigma Imperativo
#+OPTIONS: toc:nil
#+LATEX_HEADER: \usepackage[brazil,english]{babel}

#+language: pt
#+macro: lang @@latex:\selectlanguage{$1}@@
{{{lang(english)}}}
#+begin_abstract
whatever
#+end_abstract
{{{lang(portuguese)}}}
#+begin_abstract
Esse artigo visa demostrar a especificidades do paradigma imperativo, além de exibir uma análise de como o mesmo se contrapõe com o paradigma funcional. Para que a visualização e entendimento sejam claros serão utilizadas tabelas contrastando essas diferenças.
#+end_abstract



* Relação com Engenharia de Software

  Uma linguagem de programação é a padronização de métodos que tem como objetivo comunicar instruções um computador mantendo a mesma estrutura sintática. Não obstante, um paradigma de programação é a visão que o indivíduo que digita o código tem sobre a estrutura e execuçjão de um programa. O que nos leva a concluir que diferentes linguagem fazem escolhas diferentes quanto a forma e compilação dos mesmos, dependendo da visão que o seu autor vê como o mais ajustado para enfrentar os seus desafios e problemas que a mesma tenta resolver. Portanto, como enegenheiros de software é imprescindível que possamos entender as características básicas que diferenciam as principais linguagens de programação do mercado, permitindo a escolha da linguagem mais apropriada para o desenvolvimento de um software para um possível contratante.

* Contextualização

  Mas o que torna uma linguagem imperativa? Basicamente um programa encrito de maneira imperativa possui duas característica básicas:

  - Um estado do programa;
  - Instruções que alteram o estado do programa.

  Por intruções pode se inferir o sentido lexical da palavra de mandar, ou imperar que uma atividade seja executada de forma autoritária. Uma frase que é usualmente  usada na literatura para decrever esse paradigma é

  #+BEGIN_QUOTE
  Primeiro faça isso, depois faça aquilo.
  #+END_QUOTE

  Indicando que o prgramador é diretamente responsável por preconceber todos os caminhos em que o usuário vai poder percorrer. O problema começa a aparecer quando o tamanho do programa cresce. Maiores programas oferecem mais "caminhos" aos usuário, que exponecialmente aumentam a combinações de rotas possíveis em que o usuário teóricamente tem acesso. Com isso situações atípicas podem intruduzir bugs de difícil reconhecimento tornando o código de difícil manutenção.

* Modelo Computacional

  O paradigma imperativo também é conhecido por paradigma procedural, é o modelo de programação mais antigo. Na década de 40, John von Neumann e outros cientistas da computação se dão conta de que assim como o programa, seus dados podem ser guardados na memória principal da aplicação. Touring também trabalhaca na mesma linha de pensamento à época e é esse conceito que fundamenta o paradigma imperativo. A atribuição de novos valores às variáveis que residem em memória é o cerne do conceito.
  Essas declarações atribuem locais de memória e nome para cada variável e associam tipos aos valores armazenados. A execução do programa é basicamente síncrona; isto é, eles são executados na mesma ordem em que aparecem na memória. Entretanto, tanto variações condicionais quando incondicionais podem alterar o fluxo normal de execução. Os fatos de que um programa alocar dinamicamente variaveis e seus valores em memória , bem como, possuir comandos de ramificação e/ou condicionais que permitem que um determinado comando deixe de ser executado ou seja repetidamente executado tornam uma linguagem completa quanto a Touring.
  Essa medida, é importante por que apresenta um conjunto mínimo de recusos que uma linguagem de programação deve possuir ; a fim de ser capaz de expressar qualquer algoritmo a ser cocebido. Segundo TUCKER(2010):
  #+BEGIN_QUOTE
  Linguagens imperativas que contêm variáveis e valores inteiros, operações aritméticas básicas, comandos de atribuição, seqüenciamento de comandos baseados em memórias, condições e comandos de ramificação são “completas quanto a Turing”
  #+END_QUOTE

* Características

  A fim de ser considerada imperativa uma linguagem tem de obrigatoriamente ser completa quanto a Touring e suportar características mais elaboradas que se tornaram mais necessárias com a evolução da ciência como um todo. São eles

  - Estruturas de controle.
  - Entrada/saída.
  - Manipulação de exceções e erros.
  - Expressões e atribuição.
  - Abstração procedural.
  - Suporte de biblioteca para estruturas de dados.

  Enquanto os três primeiros ítems são inerentes à Touring, os três ultimos fazem referência a essas características mais contemporâneas do paradigma. São esse pontos em que o artigo tenta focar, por serem as características que mais variam dependendo da linguagem a ser observada.

** Expressões e Atribuições

A sentença imperativa mais trivial é a de atribuição. Onde o resultado de uma expressão é atribuido a uma variável alvo em memória. Existe uma variedade de operadores de atribuição, entretanto os mais usuais são _=_ e _:=_. Exemplos de linguagens que usa o primeiro operador são Fortran, Java e C, enquanto Golang, Algol e Swift usa o último.

#+BEGIN_SRC go
alvo = expressão
alvo := expressão
#+END_SRC
** Abstração Procedural
   É a capacidade de extrair pequenas unidades lógicas que permitem o programador abstrair a implementação de um algarismo, possibilitando um maior foco no valor da algoritmo do que sua implementação em sí. Considere esse simples programa escrito em Golang. Dado um array de inteiros chamado _list_, ele imprime na tela verdadeiro ou falso, dependendo do valor da variável _check_.
   #+begin_src go :imports '("fmt" "log" "time")
func main() {
    var list = []int{2, 3, 3}
    var check = 3
    for _, a := range list {
        if a == check {
	            log.Println(true)
	        }
    }
    log.Println(false)
}
   #+end_src

   Já no exemplo a seguir, o resultado é o mesmo, entretanto as instruções utilizadas para gerar o resultado do algoritmo que indentifica se a variével _check_ está em _ list_ foram abstraidos para uma função chamada _contains_. Nesse caso, a implementação é pequena, apenas seis linhas, mas é fácil perceber como esse processo permite que grandes algoritmos não atrapalhem a legibilidade do código escrito. Uma vez abstraído para uma função, o algoritmo agora pode ser reultilizada em diferentes partes do programa,


   #+begin_src go :imports '("fmt" "log" "time")
func main() {
    var list = []int{1, 2, 3}
	    var check = 3
	    log.Println(contains(list, check))
}

func contains(s []int, e int) bool {
    for _, a := range s {
	        if a == e {
		            return true
		        }
	    }
	    return false
}
   #+end_src


** Suporte de Bibliotecas para estrutura de Dados

   Linguagens modernas disponibilizam bibliotes de funções básicas que facialitam o desenvolvimento de softwares mais complexos, ultilizando a abstração procedural para encapsular funções que irão acabar sendo usadas na maioria do programas, evitando que desenvolvedores "reinventem a roda". Na linguagem Golang, essa biblioteca se chama "standard library" e possui uma lista grande de "packages" que podem ser importados individualmente para facilitar partes específicas do processo de desenvolvimento de software. Algumas delas são:

| Packages | Função                         |
|----------+--------------------------------|
| net/http | servidores web                 |
| strconv  | conversão de strings           |
| flag     | argumentos de linha de comando |
| math     | operações matemáticas          |
| strings  | manipulação destrings          |

* Bibliografia

- TUCKER, A. B.; NOONAN R. Linguagens de programação - Princípios e paradigmas. 2a ed. Porto Alegre: AMGH, 2010. 630 p.
- BROOKSHEAR, J. G. Ciência da Computação: uma visão abrangente. 11a ed. Capítulo 6 - Linguagens de Programação. Porto Alegre: Bookman, 2013. 561 p.
